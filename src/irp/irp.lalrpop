use std::str::FromStr;
use crate::irp::ast::*;
use crate::irp::box_option;

grammar;

GeneralItem: GeneralItem = {
    "msb" => GeneralItem::OrderMsb,
    "lsb" => GeneralItem::OrderLsb,
    <float_number> "p" => GeneralItem::Unit(<>, Unit::Pulses),
    <float_number> => GeneralItem::Unit(<>, Unit::Microseconds),
    <float_number> "k" => GeneralItem::Frequency(<>),
    <float_number> "%" => GeneralItem::DutyCycle(<>),
}

number: i64 = {
    r"\d+" => i64::from_str(<>).unwrap(),
}

float_number: f64 = {
    r"\d+"  => f64::from_str(<>).unwrap(),
    r"\d+\.\d+" => f64::from_str(<>).unwrap(),
}

identifier: String = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => <>.to_string(),
}

unit: Unit = {
    "u" => Unit::Microseconds,
    "m" => Unit::Milliseconds,
    "p" => Unit::Pulses,
}

expression: Expression = {
    // FIXME: Ternary is currently not parsed. This produces shift/reduce errors
    Precedence13,
    definition,
}

Precedence14: Expression = {
    <c:Precedence14> "?" <l:Precedence13> ":" <r:Precedence13> => {
        Expression::Ternary(Box::new(c), Box::new(l), Box::new(r))
    },
    Precedence13,
}

Precedence13: Expression = {
    <l:Precedence13> "||" <r:Precedence12> => Expression::Or(Box::new(l), Box::new(r)),
    Precedence12,
}

Precedence12: Expression = {
    <l:Precedence12> "&&" <r:Precedence11> => Expression::And(Box::new(l), Box::new(r)),
    Precedence11,
}

Precedence11: Expression = {
    <l:Precedence11> "==" <r:Precedence10> => Expression::Equal(Box::new(l), Box::new(r)),
    <l:Precedence11> "!=" <r:Precedence10> => Expression::NotEqual(Box::new(l), Box::new(r)),
    Precedence10,
}

Precedence10: Expression = {
    <l:Precedence10> "<=" <r:Precedence9> => Expression::LessEqual(Box::new(l), Box::new(r)),
    <l:Precedence10> "<" <r:Precedence9> => Expression::Less(Box::new(l), Box::new(r)),
    <l:Precedence10> ">=" <r:Precedence9> => Expression::MoreEqual(Box::new(l), Box::new(r)),
    <l:Precedence10> ">" <r:Precedence9> => Expression::More(Box::new(l), Box::new(r)),
    Precedence9,
}

Precedence9: Expression = {
    <l:Precedence9> "|" <r:Precedence8> => Expression::BitwiseOr(Box::new(l), Box::new(r)),
    Precedence8,
}

Precedence8: Expression = {
    <l:Precedence8> "^" <r:Precedence7> => Expression::BitwiseXor(Box::new(l), Box::new(r)),
    Precedence7,
}

Precedence7: Expression = {
    <l:Precedence7> "&" <r:Precedence6> => Expression::BitwiseAnd(Box::new(l), Box::new(r)),
    Precedence6,
}

Precedence6: Expression = {
    <l:Precedence6> "<<" <r:Precedence5> => Expression::ShiftLeft(Box::new(l), Box::new(r)),
    <l:Precedence6> ">>" <r:Precedence5> => Expression::ShiftRight(Box::new(l), Box::new(r)),
    Precedence5,
}

Precedence5: Expression = {
    <l:Precedence5> "+" <r:Precedence4> => Expression::Add(Box::new(l), Box::new(r)),
    <l:Precedence5> "-" <r:Precedence4> => Expression::Subtract(Box::new(l), Box::new(r)),
    Precedence4,
}

Precedence4: Expression = {
    <l:Precedence4> "*" <r:Precedence3> => Expression::Multiply(Box::new(l), Box::new(r)),
    <l:Precedence4> "/" <r:Precedence3> => Expression::Divide(Box::new(l), Box::new(r)),
    <l:Precedence4> "%" <r:Precedence3> => Expression::Modulo(Box::new(l), Box::new(r)),
    Precedence3,
}

Precedence3: Expression = {
    <l:Precedence3> "**" <r:Precedence2> => Expression::Power(Box::new(l), Box::new(r)),
    Precedence2,
}

Precedence2: Expression = {
    "~" <e:Precedence2> => Expression::Complement(Box::new(e)),
    "-" <e:Precedence2> => Expression::Negative(Box::new(e)),
    "!" <e:Precedence2> => Expression::Not(Box::new(e)),
    "#" <e:Precedence2> => Expression::BitCount(Box::new(e)),
    Precedence1,
}

Precedence1: Expression = {
    <e:Precedence0> ":" <r:"-"?> <l:Precedence0> <b:(":" <Precedence0>)?> => {
        Expression::BitField {
            value: Box::new(e),
            reverse: r.is_some(),
            length: Box::new(l),
            skip: box_option(b),
        }
    },
    Precedence0,
}

Precedence0: Expression = {
    number => Expression::Number(<>),
    identifier => Expression::Identifier(<>),
    <n:float_number> <u:unit> => Expression::FlashConstant(n, u),
    "^" <n:float_number> <u:unit> => Expression::ExtentConstant(n, u),
    "^" <n:float_number> => Expression::ExtentConstant(n, Unit::Units),
    <id:identifier> <u:unit> => Expression::FlashIdentifier(id, u),
    "^" <id:identifier> <u:unit> => Expression::ExtentIdentifier(id, u),
    "^" <id:identifier> => Expression::ExtentIdentifier(id, Unit::Units),
    expression_list => <>,
}

definition: Expression = {
    <id:identifier> "=" <e:expression> => Expression::Assignment(id, Box::new(e)),
}

RepeatMarker: RepeatMarker = {
    "*" => RepeatMarker::Any,
    "+" => RepeatMarker::OneOrMore,
    <number> => RepeatMarker::Count(<>),
    <number> "+" => RepeatMarker::CountOrMore(<>),
}

expression_list: Expression = {
    "(" <v:CommaList<expression>> ")" => Expression::List(v),
}

IrStream: IrStream = {
    <v:expression_list> <r:RepeatMarker?> => {
        IrStream{ stream: v, repeat: r }
    }
}

bit_spec1: Expression = {
    <v:CommaList<Precedence2>> => Expression::List(v),
}

bit_spec: Vec<Expression> = {
    "<" <PipeList<bit_spec1>> ">" => <>,
}

definitions: Vec<Expression> = {
    => Vec::new(),
    "{" <CommaList<definition>> "}" => <>,
}

parameter_specs: Vec<ParameterSpec> = {
    => Vec::new(),
    "[" <s:CommaList<parameter_spec>> "]" => s,
}

parameter_spec: ParameterSpec = {
    <name:identifier> ":" <min:number> ".." <max:number> <default:("=" <expression>)?> => {
        ParameterSpec {
            name,
            memory: false,
            min,
            max,
            default,
        }
    },
    <name:identifier> "@" ":" <min:number> ".." <max:number> "=" <default:expression> => {
        ParameterSpec {
            name,
            memory: true,
            min,
            max,
            default: Some(default),
        }
    },
}

pub protocol: Irp = {
    "{" <v:CommaList<GeneralItem>> "}" <b:bit_spec> <ir:IrStream> <d:definitions> <s:parameter_specs> => {
        Irp { general_spec: v, bit_spec: b, stream: ir, definitions: d, parameters: s }
    }
}

CommaList<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

PipeList<T>: Vec<T> = {
    <v:(<T> "|")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

use std::str::FromStr;
use crate::irp::ast::*;

grammar;

GeneralItem: GeneralItem = {
    "msb" => GeneralItem::OrderMsb,
    "lsb" => GeneralItem::OrderLsb,
    <float_number> "p" => GeneralItem::Unit(<>, Unit::Pulses),
    <float_number> => GeneralItem::Unit(<>, Unit::Microseconds),
    <float_number> "k" => GeneralItem::Frequency(<>),
    <float_number> "%" => GeneralItem::DutyCycle(<>),
}

number: i64 = {
    r"\d+" => i64::from_str(<>).unwrap(),
}

float_number: f64 = {
    r"\d+"  => f64::from_str(<>).unwrap(),
    r"\d+\.\d+" => f64::from_str(<>).unwrap(),
}

identifier: String = {
    r"[a-zA-Z_][a-zA-Z_0-9]*" => <>.to_string(),
}

unit: Unit = {
    "u"? => Unit::Microseconds,
    "m" => Unit::Milliseconds,
    "p" => Unit::Pulses,
}

duration: Duration = {
    <n:float_number> <u:unit> => Duration::FlashConstant(n, u),
    "-" <n:float_number> <u:unit> => Duration::GapConstant(n, u),
    "^" <n:float_number> <u:unit> => Duration::ExtentConstant(n, u),
    <id:identifier> <u:unit> => Duration::FlashIdentifier(id, u),
    "-" <id:identifier> <u:unit> => Duration::GapIdentifier(id, u),
    "^" <id:identifier> <u:unit> => Duration::ExtentIdentifier(id, u),
}

irstream_item: IrStreamItem = {
    duration => IrStreamItem::Duration(<>),
    <id:identifier> "=" <e:expression> => IrStreamItem::Assignment(id, e),
    <c:"~"?> <e:primary_item> ":" <r:"-"?> <b:primary_item> <l:(":" <primary_item>)?> => {
        IrStreamItem::BitField(c.is_some(), e, r.is_some(), b, l)
    },
    <c:"~"?> <e:primary_item> "::" <b:primary_item> => {
        IrStreamItem::InfiniteBitField(c.is_some(), e, b)
    }
}

primary_item: Expression = {
    identifier => Expression::Identifier(<>),
    number => Expression::Number(<>),
    "(" <e:expression> ")" => e,
}

expression: Expression = {
    Precedence14,
}

Precedence14: Expression = {
    <c:Precedence14> "?" <l:Precedence13> ":" <r:Precedence13> => {
        Expression::Ternary(Box::new(c), Box::new(l), Box::new(r))
    },
    Precedence13,
}

Precedence13: Expression = {
    <l:Precedence13> "||" <r:Precedence12> => Expression::Or(Box::new(l), Box::new(r)),
    Precedence12,
}

Precedence12: Expression = {
    <l:Precedence12> "&&" <r:Precedence11> => Expression::And(Box::new(l), Box::new(r)),
    Precedence11,
}

Precedence11: Expression = {
    <l:Precedence11> "==" <r:Precedence10> => Expression::Equal(Box::new(l), Box::new(r)),
    <l:Precedence11> "!=" <r:Precedence10> => Expression::NotEqual(Box::new(l), Box::new(r)),
    Precedence10,
}

Precedence10: Expression = {
    <l:Precedence10> "<=" <r:Precedence9> => Expression::LessEqual(Box::new(l), Box::new(r)),
    <l:Precedence10> "<" <r:Precedence9> => Expression::Less(Box::new(l), Box::new(r)),
    <l:Precedence10> ">=" <r:Precedence9> => Expression::MoreEqual(Box::new(l), Box::new(r)),
    <l:Precedence10> ">" <r:Precedence9> => Expression::More(Box::new(l), Box::new(r)),
    Precedence9,
}

Precedence9: Expression = {
    <l:Precedence9> "|" <r:Precedence8> => Expression::BitwiseOr(Box::new(l), Box::new(r)),
    Precedence8,
}

Precedence8: Expression = {
    <l:Precedence8> "^" <r:Precedence7> => Expression::BitwiseXor(Box::new(l), Box::new(r)),
    Precedence7,
}

Precedence7: Expression = {
    <l:Precedence7> "&" <r:Precedence6> => Expression::BitwiseAnd(Box::new(l), Box::new(r)),
    Precedence6,
}

Precedence6: Expression = {
    <l:Precedence6> "<<" <r:Precedence5> => Expression::ShiftLeft(Box::new(l), Box::new(r)),
    <l:Precedence6> ">>" <r:Precedence5> => Expression::ShiftRight(Box::new(l), Box::new(r)),
    Precedence5,
}

Precedence5: Expression = {
    <l:Precedence5> "+" <r:Precedence4> => Expression::Add(Box::new(l), Box::new(r)),
    <l:Precedence5> "-" <r:Precedence4> => Expression::Subtract(Box::new(l), Box::new(r)),
    Precedence4,
}

Precedence4: Expression = {
    <l:Precedence4> "*" <r:Precedence3> => Expression::Multiply(Box::new(l), Box::new(r)),
    <l:Precedence4> "/" <r:Precedence3> => Expression::Divide(Box::new(l), Box::new(r)),
    <l:Precedence4> "%" <r:Precedence3> => Expression::Modulo(Box::new(l), Box::new(r)),
    Precedence3,
}

Precedence3: Expression = {
    <l:Precedence3> "**" <r:Precedence2> => Expression::Power(Box::new(l), Box::new(r)),
    Precedence2,
}

Precedence2: Expression = {
    "~" <e:Precedence2> => Expression::Complement(Box::new(e)),
    "-" <e:Precedence2> => Expression::Negative(Box::new(e)),
    "!" <e:Precedence2> => Expression::Not(Box::new(e)),
    "#" <e:Precedence2> => Expression::BitCount(Box::new(e)),
    Precedence1,
}

Precedence1: Expression = {
    number => Expression::Number(<>),
    identifier => Expression::Identifier(<>),
    "(" <expression> ")" => <>,
}

RepeatMarker: RepeatMarker = {
    "*" => RepeatMarker::Any,
    "+" => RepeatMarker::OneOrMore,
    <number> => RepeatMarker::Count(<>),
    <number> "+" => RepeatMarker::CountOrMore(<>),
}

IrStream: IrStream = {
    "(" <b:CommaList<irstream_item>> ")" <r:RepeatMarker?> => IrStream{ stream: b, repeat: r},
}

BareIrStream: Vec<Duration> = {
    CommaList<duration> => <>,
}

bit_spec: Vec<Vec<Duration>> = {
    "<" <PipeList<BareIrStream>> ">" => <>,
}

pub protocol: Irp = {
    "{" <v:CommaList<GeneralItem>> "}" <b:bit_spec> <ir:IrStream> => Irp { general_spec: v, bit_spec: b, stream: ir },
}

CommaList<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

PipeList<T>: Vec<T> = {
    <v:(<T> "|")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};
